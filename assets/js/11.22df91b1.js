(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{330:function(t,v,l){"use strict";l.r(v);var a=l(8),i=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"数据类型分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据类型分类"}},[t._v("#")]),t._v(" 数据类型分类")]),t._v(" "),v("h3",{attrs:{id:"原始值类型「值类型-基本数据类型」"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原始值类型「值类型-基本数据类型」"}},[t._v("#")]),t._v(" 原始值类型「值类型/基本数据类型」")]),t._v(" "),v("ul",[v("li",[t._v("number 数字")]),t._v(" "),v("li",[t._v("string 字符串")]),t._v(" "),v("li",[t._v("boolean 布尔")]),t._v(" "),v("li",[t._v("null 空对象指针")]),t._v(" "),v("li",[t._v("undefined 未定义")]),t._v(" "),v("li",[t._v("symbol 唯一值")]),t._v(" "),v("li",[t._v("bigint 大数")])]),t._v(" "),v("h3",{attrs:{id:"对象类型「引用数据类型」"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对象类型「引用数据类型」"}},[t._v("#")]),t._v(" 对象类型「引用数据类型」")]),t._v(" "),v("ul",[v("li",[t._v("标准普通对象 object")]),t._v(" "),v("li",[t._v("标准特殊对象 Array、RegExp、Date、Math、Error……")]),t._v(" "),v("li",[t._v("非标准特殊对象 Number、String、Boolean……")]),t._v(" "),v("li",[t._v("可调用/执行对象「函数」function")])]),t._v(" "),v("h2",{attrs:{id:"数据类型检测"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据类型检测"}},[t._v("#")]),t._v(" 数据类型检测")]),t._v(" "),v("h3",{attrs:{id:"typeof"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typeof"}},[t._v("#")]),t._v(" typeof")]),t._v(" "),v("ul",[v("li",[t._v("返回的结果是字符串，字符串中包含了对应的数据类型")]),t._v(" "),v("li",[t._v("按照计算机底层存储的二进制进行检测")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),v("p",[t._v('null是以0开头进行存储的，跟对象一样，所以typeof null->"object"\ntypeof []->"object"  typeof function(){} ->"function"  typeof Symbol()->"symbol"\ntypeof 10n->"bigint"')])]),t._v(" "),v("h2",{attrs:{id:"数据类型转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据类型转换"}},[t._v("#")]),t._v(" 数据类型转换")]),t._v(" "),v("h3",{attrs:{id:"把其它数据类型转换为number"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#把其它数据类型转换为number"}},[t._v("#")]),t._v(" 把其它数据类型转换为number")]),t._v(" "),v("ul",[v("li",[t._v("Number([val])\n"),v("ul",[v("li",[t._v("一般用于浏览器的隐式转换中")]),t._v(" "),v("li",[t._v("规则\n"),v("ul",[v("li",[t._v("把字符串转换为数字：空字符串变为0，如果出现任何一个非有效数字字符，结果都是NaN")]),t._v(" "),v("li",[t._v("把布尔转换为数字：true->1  false->0")]),t._v(" "),v("li",[t._v("null->0  undefined->NaN")]),t._v(" "),v("li",[t._v("Symbol无法转换为数字，会报错：Uncaught TypeError: Cannot convert a Symbol value to a number")]),t._v(" "),v("li",[t._v("BigInt去除“n”（超过安全数字的，会按照科学计数法处理）")]),t._v(" "),v("li",[t._v("把对象转换为数字："),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("1.先调用对象的 Symbol.toPrimitive 这个方法，如果不存在这个方法\n2.再调用对象的 valueOf 获取原始值，如果获取的值不是原始值\n3.再调用对象的 toString 把其变为字符串\n4.最后再把字符串基于Number方法转换为数字\n")])])])])])])])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),v("p",[t._v("Numer([])->0,数组中超过1个非有效数字,转换结果就是NaN")])]),t._v(" "),v("ul",[v("li",[t._v("parseInt([val],[radix])\n"),v("ul",[v("li",[t._v("radix不写或者写0，默认是10进制「如果第一个传递的字符串是以“0x”开始的，那么默认是16进制」")]),t._v(" "),v("li",[t._v("radix取值范围：2~36，不在这个范围内，处理的结果都是NaN")]),t._v(" "),v("li",[t._v("在传递的字符串中，从左到右，找到符合radix进制的值{遇到不符合的则结束查找}，把找到的值，看做radix进制，最后转换为10进制")]),t._v(" "),v("li",[t._v("把其它进制的值转换为10进制：“按权展开求和”")])])]),t._v(" "),v("li",[t._v("parseFloat([val])\n"),v("ul",[v("li",[t._v("一般用于手动转换")]),t._v(" "),v("li",[t._v("规则：[val]值必须是一个字符串，如果不是则先转换为字符串；然后从字符串左侧第一个字符开始找，把找到的有效数字字符最后转换为数字「一个都没找到就是NaN」；遇到一个非有效数字字符，不论后面是否还有有效数字字符，都不再查找了；parseFloat可以多识别一个小数点；")])])])]),t._v(" "),v("h3",{attrs:{id:"把其它类型转换为string"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#把其它类型转换为string"}},[t._v("#")]),t._v(" 把其它类型转换为string")]),t._v(" "),v("ul",[v("li",[t._v("[val].toString() & String([val])\n"),v("ul",[v("li",[t._v("原始值类型：基于引号包起来、bigint会去掉n")]),t._v(" "),v("li",[t._v("对象值类型：\n"),v("ul",[v("li",[t._v("调用Symbol.toPrimitive")]),t._v(" "),v("li",[t._v("如果不存在则继续调用valueOf获取原始值，有原始值则把其转换为字符串")]),t._v(" "),v("li",[t._v('如果不是原始值，则调用toString转换为字符串\n特殊：普通对象转换为字符串是"[object,Object]" ->Object.prototype.toString')])])]),t._v(" "),v("li",[t._v("“+”代表的字符串拼接\n"),v("ul",[v("li",[t._v("有两边，一边是字符串，则会变为字符串拼接")]),t._v(" "),v("li",[t._v("有两边，一边是对象，按照Symbol.toPrimitive -> valueOf ->toString 处理，变为字符串后，就直接按照字符串拼接处理了。特殊：{}+10 ->10  他认为{}是代码块，处理的只是+10这个操作")]),t._v(" "),v("li",[t._v("只出现在左边，例如：+[val] 这是把[val]转换为数字")])])])])]),t._v(" "),v("li",[t._v("Object.prototype.toString")])]),t._v(" "),v("h3",{attrs:{id:"把其它类型转换为布尔"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#把其它类型转换为布尔"}},[t._v("#")]),t._v(" 把其它类型转换为布尔")]),t._v(" "),v("ul",[v("li",[t._v("除了“0/NaN/空字符串/null/undefined”五个值是false，其余都是true")])]),t._v(" "),v("h3",{attrs:{id:"比较时候的相互转换规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#比较时候的相互转换规则"}},[t._v("#")]),t._v(" “==”比较时候的相互转换规则")]),t._v(" "),v("ul",[v("li",[t._v("“==”相等，两边数据类型不同，需要先转为相同类型，然后再进行比较\n"),v("ul",[v("li",[t._v("对象==字符串   对象转换为字符串「Symbol.toPrimitive -> valueOf -> toString」")]),t._v(" "),v("li",[t._v("null==undefined  -> true   null/undefined和其他任何值都不相等 null===undefined -> false")]),t._v(" "),v("li",[t._v("对象==对象  比较的是堆内存地址，地址相同则相等")]),t._v(" "),v("li",[t._v("NaN!==NaN")]),t._v(" "),v("li",[t._v("除了以上情况，只要两边类型不一致，剩下的都是转换为数字，然后再进行比较的")])])]),t._v(" "),v("li",[t._v("“===”绝对相等，如果两边类型不同，则直接是false，不会转换数据类型「推荐」")])])])}),[],!1,null,null,null);v.default=i.exports}}]);